---
layout: post
title: "React에서 '불가능한' UI 상태를 추방하는 법: 타입스크립트로 견고함을 더하다"
date: 2026-01-14T00:40:45.437Z
categories: [frontend, tech]
tags: [react, javascript, nextjs, typescript, tailwindcss]
---

안녕하세요, 프론트엔드 개발 전문 블로거 개발하는 코알라입니다!
2026년 1월 14일, 오늘도 뜨거운 프론트엔드 세계의 최신 트렌드를 들고 왔습니다. 빠르게 변화하는 기술 속에서 개발자들이 주목해야 할 핵심 주제들을 함께 살펴보시죠!

---



## 소개

프론트엔드 개발자라면 누구나 한 번쯤 겪어봤을 겁니다. 로딩 스피너가 돌아가고 있는데 동시에 에러 메시지가 뜬다거나, 데이터가 없는 상태인데 마치 있는 것처럼 UI가 렌더링 되는 불가능한 UI 상태 말이죠. 이러한 버그는 사용자 경험을 해칠 뿐만 아니라, 디버깅에도 많은 시간을 소모하게 만듭니다. 오늘 우리는 React 애플리케이션에서 이러한 유효하지 않은 UI 상태를 타입스크립트를 활용해 원천적으로 불가능하게 만드는 방법을 알아보려 합니다.

## 본문

### 핵심 개념 설명: 불가능한 상태, 그리고 타입 안전성

우리가 흔히 React 컴포넌트에서 상태를 관리할 때, 여러 개의 독립적인 `boolean` 플래그와 `null`이 될 수 있는 데이터를 함께 사용하는 경우가 많습니다.

```typescript
interface DataState {
  isLoading: boolean;
  isError: boolean;
  data: User | null;
  error: string | null;
}

const [state, setState] = useState<DataState>({
  isLoading: false,
  isError: false,
  data: null,
  error: null,
});
```

이 방식의 문제는 `isLoading`이 `true`이면서 동시에 `isError`도 `true`인 상태가 타입 시스템 상으로는 유효하다는 점입니다. 실제로는 이 두 가지 상태가 동시에 발생할 수 없는데도 말이죠. 이런 '불가능한' 상태는 런타임에 예상치 못한 버그를 유발하고, 조건부 렌더링 로직을 복잡하게 만듭니다.

이 문제를 해결하기 위한 핵심은 바로 **판별 유니언(Discriminated Unions)** 패턴을 활용하는 것입니다. 판별 유니언은 여러 개의 인터페이스나 타입을 하나의 유니언 타입으로 묶고, 각 타입이 특정 속성(판별자, discriminator)의 값으로 구분되도록 하는 타입스크립트의 강력한 기능입니다. 이를 통해 우리는 컴포넌트가 가질 수 있는 모든 '유효한' 상태를 명시적으로 정의하고, '불가능한' 상태는 타입 레벨에서 허용되지 않도록 만들 수 있습니다.

예를 들어, 데이터 로딩 상태를 관리한다고 할 때, 다음과 같이 유효한 상태들을 정의할 수 있습니다:
1.  **초기 상태 (idle):** 아무 작업도 시작하지 않음.
2.  **로딩 중 상태 (loading):** 데이터를 불러오는 중.
3.  **성공 상태 (success):** 데이터를 성공적으로 불러옴. (데이터 포함)
4.  **에러 상태 (error):** 데이터 불러오기 실패. (에러 메시지 포함)

각 상태는 고유한 `status` 값을 가지며, 그 `status` 값에 따라 포함할 수 있는 데이터가 달라집니다.

### 실제 코드 예시 (React + TypeScript)

사용자 프로필을 불러오는 컴포넌트를 예시로 들어보겠습니다.

먼저, `User` 데이터 타입과 각 상태를 정의합니다.

```typescript
// src/types/user.ts
export type User = {
  id: string;
  name: string;
  email: string;
};

// src/types/fetchState.ts
export type FetchState<T> =
  | { status: 'idle' } // 초기 상태
  | { status: 'loading' } // 로딩 중
  | { status: 'success'; data: T } // 성공 시 데이터 포함
  | { status: 'error'; message: string }; // 에러 시 메시지 포함
```

이제 `UserProfile` 컴포넌트에서 이 `FetchState`를 활용해 상태를 관리해봅니다.

```tsx
// src/components/UserProfile.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { User, FetchState } from '../types'; // 위에서 정의한 타입 임포트

async function fetchUserData(): Promise<User> {
  // 실제 API 호출 로직 (예시)
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (Math.random() > 0.3) { // 70% 확률로 성공
        resolve({ id: '1', name: '김코알라', email: 'koala@example.com' });
      } else { // 30% 확률로 실패
        reject(new Error('사용자 정보를 불러오는데 실패했습니다.'));
      }
    }, 1500);
  });
}

function UserProfile() {
  const [userState, setUserState] = useState<FetchState<User>>({ status: 'idle' });

  const loadUser = useCallback(async () => {
    setUserState({ status: 'loading' });
    try {
      const user = await fetchUserData();
      setUserState({ status: 'success', data: user });
    } catch (e) {
      setUserState({ status: 'error', message: e instanceof Error ? e.message : '알 수 없는 에러' });
    }
  }, []);

  useEffect(() => {
    // 컴포넌트 마운트 시 데이터 로딩 시작
    // loadUser(); // 필요에 따라 자동 로드 또는 버튼 클릭으로 로드
  }, [loadUser]);

  return (
    <div style={{ padding: '20px', border: '1px solid #ddd', borderRadius: '8px' }}>
      <h2>사용자 프로필</h2>
      {userState.status === 'idle' && (
        <>
          <p>사용자 정보를 불러올 준비가 되었습니다.</p>
          <button onClick={loadUser} style={{ padding: '10px 15px', backgroundColor: '#007bff', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' }}>
            사용자 정보 불러오기
          </button>
        </>
      )}

      {userState.status === 'loading' && (
        <p style={{ color: '#007bff' }}>로딩 중...</p>
      )}

      {userState.status === 'error' && (
        // TypeScript는 userState가 'error' 상태일 때만 message 속성에 접근 가능하도록 강제합니다.
        <p style={{ color: 'red', fontWeight: 'bold' }}>에러 발생: {userState.message}</p>
      )}

      {userState.status === 'success' && (
        // TypeScript는 userState가 'success' 상태일 때만 data 속성에 접근 가능하도록 강제합니다.
        <div>
          <p><strong>ID:</strong> {userState.data.id}</p>
          <p><strong>이름:</strong> {userState.data.name}</p>
          <p><strong>이메일:</strong> {userState.data.email}</p>
        </div>
      )}
    </div>
  );
}

export default UserProfile;
```

위 코드에서 `userState.status`를 판별자로 사용하여 조건부 렌더링을 수행합니다. 예를 들어, `userState.status === 'loading'`일 때는 `userState.data`에 접근하려고 하면 타입스크립트 에러가 발생합니다. 이는 `FetchState` 정의에 따라 `loading` 상태에는 `data` 속성이 없기 때문입니다. 이처럼 타입스크립트는 개발자가 불가능한 상태에 접근하는 것을 컴파일 시점에서 막아주어 런타임 오류를 줄여줍니다.

### 실무 적용 팁

1.  **복잡한 컴포넌트에 우선 적용:** 모든 컴포넌트에 이 패턴을 적용할 필요는 없습니다. 데이터 페칭, 여러 단계의 폼 처리, 복잡한 UI 로직을 가진 컴포넌트 등 상태 간의 의존성이 높고 불가능한 상태가 발생하기 쉬운 곳에 우선적으로 적용하면 효과를 극대화할 수 있습니다.
2.  **재사용 가능한 타입 정의:** `FetchState<T>`와 같이 제네릭을 활용하여 범용적인 상태 타입을 정의하면, 다양한 데이터 타입에 대해 재사용할 수 있어 코드의 일관성을 높일 수 있습니다.
3.  **상태 머신과의 연계:** 판별 유니언 패턴은 상태 머신(State Machine)의 개념과 매우 유사합니다. `XState` 같은 라이브러리를 사용하면 더욱 강력하고 명시적인 상태 관리가 가능하며, 타입스크립트와 결합하여 불가능한 전이(transition)까지 방지할 수 있습니다.
4.  **점진적 도입:** 기존 프로젝트에 한 번에 모든 것을 적용하기 어렵다면, 새로 개발하는 기능이나 중요한 버그를 수정하는 과정에서 이 패턴을 점진적으로 도입하는 것을 고려해 보세요.
5.  **개발자 경험 향상:** 이 패턴을 사용하면 코드의 가독성이 높아지고, 어떤 상태에서 어떤 데이터에 접근할 수 있는지 명확해지므로 팀원들과의 협업 및 유지보수가 훨씬 수월해집니다.

## 마무리

오늘 우리는 React 애플리케이션에서 타입스크립트의 판별 유니언 패턴을 활용하여 '불가능한' UI 상태를 제거하고, 더 견고하고 예측 가능한 코드를 작성하는 방법을 살펴보았습니다. 초기에는 다소 생소하게 느껴질 수 있지만, 이 패턴을 익히고 나면 런타임 에러를 줄이고 개발 생산성을 크게 향상시킬 수 있음을 경험하게 될 것입니다.

더 나아가, 복잡한 상태 관리가 필요하다면 `XState`와 같은 상태 머신 라이브러리 학습을 통해 이 개념을 더욱 확장해 보는 것을 추천합니다. 타입스크립트와 함께라면 더욱 강력한 프론트엔드 애플리케이션을 구축할 수 있습니다!

---

## 참고 자료

-   [Type-Safe React: Making Invalid UI States Impossible](https://dev.to/tarunmj6/type-safe-react-making-invalid-ui-states-impossible-2k4d) by Tarun Moorjani
-   [Por que o seu Design System está morrendo (e como começamos a salvá-lo)](https://dev.to/augustosandim/por-que-o-seu-design-system-est-morrendo-e-como-comecamos-a-salva-lo-546l) by Augusto Sandim
-   [I Over Engineered My Portfolio Into an Operating System. No Regrets.](https://dev.to/dineshgit17/i-over-engineered-my-portfolio-into-an-operating-system-no-regrets-e52) by Dinesh Dawonauth
-   [React Performance Problems Usually Start with State, Not Rendering](https://dev.to/wmdn9116/react-performance-problems-usually-start-with-state-not-rendering-1lk4) by Shamim Ali
-   [Stop Fighting TypeScript in React: Common Frustrations and How to Fix Them](https://dev.to/tarunmj6/stop-fighting-typescript-in-react-common-frustrations-and-how-to-fix-them-19a8) by Tarun Moorjani