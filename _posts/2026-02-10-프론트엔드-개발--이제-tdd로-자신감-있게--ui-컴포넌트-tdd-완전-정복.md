---
layout: post
title: "프론트엔드 개발, 이제 TDD로 자신감 있게! UI 컴포넌트 TDD 완전 정복"
date: 2026-02-10T01:03:15.800Z
categories: [frontend, tech]
tags: [react, javascript, nextjs, typescript, tailwindcss]
---

안녕하세요, 프론트엔드 개발 전문 기술 블로거, 여러분의 든든한 동료 프론티(Frontie)입니다!
오늘 날짜는 2026년 2월 10일, 여전히 빠르게 변화하는 프론트엔드 세계에서 우리는 매일 새로운 기술과 트렌드를 마주하고 있습니다. 오늘은 그중에서도 '탄탄한 프론트엔드 애플리케이션'을 위한 가장 기본적인, 하지만 강력한 무기 중 하나인 **테스트 주도 개발(TDD)**에 대해 이야기해보려 합니다.

---



## 복잡한 UI, TDD로 버그와 작별하세요!

현대의 웹 애플리케이션은 사용자 경험을 최우선으로 여기며, 그만큼 UI 컴포넌트의 복잡성과 상호작용이 급증하고 있습니다. 이러한 복잡성은 필연적으로 버그 발생 가능성을 높이고, 유지보수를 어렵게 만들죠. 바로 이때, **테스트 주도 개발(TDD)**은 우리의 개발 워크플로우를 혁신하고, 견고하며 신뢰할 수 있는 UI를 구축하는 데 필수적인 방법론이 됩니다. 코드를 작성하기 전에 테스트를 먼저 작성함으로써, 우리는 요구사항을 명확히 하고, 더 나은 설계를 유도하며, 미래의 리팩토링에도 자신감을 가질 수 있습니다.

## TDD, UI 개발의 든든한 가이드

TDD는 'Red-Green-Refactor'라는 세 가지 핵심 단계로 이루어진 개발 사이클입니다.
1.  **Red (실패하는 테스트 작성)**: 구현하려는 기능에 대한 테스트 코드를 먼저 작성합니다. 당연히 아직 기능이 없으므로 이 테스트는 실패해야 합니다.
2.  **Green (테스트를 통과하는 최소한의 코드 작성)**: 실패한 테스트를 통과시킬 수 있는 최소한의 실제 코드를 작성합니다. 이 단계에서는 오직 테스트 통과가 목표입니다.
3.  **Refactor (코드 리팩토링)**: 테스트가 모두 통과하면, 이제 코드를 더 깔끔하고 효율적으로 리팩토링합니다. 이 과정에서 테스트가 깨지지 않는지 확인하며 코드의 품질을 유지합니다.

이 사이클을 반복하면서 우리는 점진적으로 기능을 구현하고, 동시에 해당 기능에 대한 견고한 테스트 스위트를 구축하게 됩니다. 특히 UI 컴포넌트 개발에서는 이 접근 방식이 더욱 빛을 발합니다. 사용자 시나리오를 바탕으로 테스트를 작성하기 때문에, 실제 사용자가 겪을 수 있는 다양한 상황을 미리 대비하고 안정적인 컴포넌트를 만들 수 있습니다.

### React/Next.js/TypeScript를 활용한 TDD 예시: `ToggleButton` 컴포넌트

간단한 `ToggleButton` 컴포넌트를 TDD 방식으로 개발하는 과정을 살펴보겠습니다. 목표는 다음과 같습니다:
*   버튼의 텍스트를 렌더링해야 합니다.
*   클릭 시 `onToggle` 콜백 함수를 호출해야 합니다.
*   `initialState`에 따라 초기 토글 상태를 설정할 수 있어야 합니다.
*   클릭 시 토글 상태가 변경되어야 합니다.

우리는 `react-testing-library`와 `jest`를 사용할 것입니다.

**1. Red: 실패하는 테스트 작성**

먼저, `ToggleButton` 컴포넌트가 렌더링될 때 `children`으로 전달된 텍스트를 제대로 보여주는지 확인하는 테스트부터 작성해봅시다.

```typescript
// src/components/ToggleButton/ToggleButton.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import ToggleButton from './ToggleButton';

describe('ToggleButton', () => {
  it('버튼 텍스트를 올바르게 렌더링해야 한다', () => {
    render(<ToggleButton onToggle={() => {}}>클릭하세요</ToggleButton>);
    expect(screen.getByText('클릭하세요')).toBeInTheDocument();
  });

  it('클릭 시 onToggle 콜백을 호출해야 한다', () => {
    const handleToggle = jest.fn(); // Mock 함수 생성
    render(<ToggleButton onToggle={handleToggle}>토글</ToggleButton>);
    
    const button = screen.getByText('토글');
    fireEvent.click(button); // 버튼 클릭 이벤트 발생

    expect(handleToggle).toHaveBeenCalledTimes(1); // 콜백이 한 번 호출되었는지 확인
  });

  it('initialState에 따라 초기 토글 상태를 설정해야 한다', () => {
    render(<ToggleButton onToggle={() => {}} initialState={true}>ON</ToggleButton>);
    // 'ON' 상태를 나타내는 무언가가 렌더링되는지 (예: 클래스, aria-pressed 속성) 확인
    // 이 테스트는 아직 컴포넌트가 구현되지 않았으므로 실패할 것입니다.
    const button = screen.screen.getByText('ON');
    expect(button).toHaveAttribute('aria-pressed', 'true');
  });

  it('클릭 시 토글 상태를 변경해야 한다', () => {
    render(<ToggleButton onToggle={() => {}}>토글</ToggleButton>);
    const button = screen.getByText('토글');
    
    // 초기 상태는 false라고 가정
    expect(button).toHaveAttribute('aria-pressed', 'false');

    fireEvent.click(button);
    expect(button).toHaveAttribute('aria-pressed', 'true');

    fireEvent.click(button);
    expect(button).toHaveAttribute('aria-pressed', 'false');
  });
});

```
위 테스트를 실행하면 `ToggleButton` 컴포넌트가 아직 없으므로 대부분의 테스트가 실패할 것입니다. (Red!)

**2. Green: 테스트를 통과하는 최소한의 코드 작성**

이제 테스트를 통과시키기 위한 최소한의 코드를 작성합니다.

```typescript
// src/components/ToggleButton/ToggleButton.tsx
import React, { useState } from 'react';

interface ToggleButtonProps {
  children: React.ReactNode;
  onToggle: (isToggled: boolean) => void;
  initialState?: boolean;
}

const ToggleButton: React.FC<ToggleButtonProps> = ({ children, onToggle, initialState = false }) => {
  const [isToggled, setIsToggled] = useState(initialState);

  const handleClick = () => {
    const newState = !isToggled;
    setIsToggled(newState);
    onToggle(newState);
  };

  return (
    <button type="button" onClick={handleClick} aria-pressed={isToggled}>
      {children}
    </button>
  );
};

export default ToggleButton;
```
이제 다시 테스트를 실행하면 모든 테스트가 통과할 것입니다. (Green!)

**3. Refactor: 코드 리팩토링**

현재 코드는 매우 간단하여 당장 리팩토링할 부분이 많지 않습니다. 하지만 만약 상태 로직이 더 복잡해지거나, 스타일링 로직이 추가된다면, 테스트가 통과하는 상태에서 더 가독성 좋고 유지보수하기 쉬운 코드로 개선할 수 있습니다. 예를 들어, `aria-pressed` 속성을 컴포넌트의 시각적 상태와 동기화하는 로직을 분리하거나, `useState` 대신 `useReducer`를 사용하여 상태 관리를 더 명확하게 할 수도 있습니다.

이처럼 TDD 사이클을 통해 우리는 기능 구현과 동시에 견고한 테스트를 확보하며, 리팩토링 시에도 안심하고 코드를 개선할 수 있습니다.

### 실무 적용 팁: TDD, 이렇게 활용하세요!

1.  **작은 단위부터 시작**: 처음부터 모든 것을 TDD로 하려 하지 말고, Atomic Design 관점에서 `Atom`이나 `Molecule`과 같은 작은 컴포넌트부터 TDD를 적용해보세요. 점차 익숙해지면 더 큰 단위로 확장할 수 있습니다.
2.  **사용자 상호작용 중심**: UI 컴포넌트는 사용자와의 상호작용이 핵심입니다. `fireEvent`나 `user-event` 라이브러리를 활용하여 실제 사용자처럼 클릭, 입력, 드래그 등의 이벤트를 시뮬레이션하는 테스트를 작성하세요.
3.  **Mocking과 Stubbing 활용**: API 호출이나 전역 상태 관리 라이브러리(Redux, Recoil 등)와 같이 외부 의존성이 있는 경우, `jest.mock`이나 `msw(Mock Service Worker)` 같은 도구를 활용하여 의존성을 목킹(Mocking)하거나 스터빙(Stubbing)하여 테스트의 격리성을 높이세요.
4.  **'유의미한' 테스트에 집중**: 테스트 커버리지 100%가 항상 좋은 것은 아닙니다. 단순히 `if` 문의 모든 분기를 테스트하는 것보다, 실제 사용자가 겪을 수 있는 핵심 시나리오와 엣지 케이스를 커버하는 '유의미한' 테스트에 집중하는 것이 중요합니다.
5.  **디자이너/기획자와의 협업 도구**: TDD의 테스트 케이스는 곧 컴포넌트의 명세서 역할을 합니다. 이를 통해 디자이너나 기획자와 기능 요구사항을 더 명확하게 소통하고, 오해를 줄일 수 있습니다.

## TDD, 개발자의 자신감이자 코드의 품질 보증서

TDD는 단순히 테스트 코드를 작성하는 기술을 넘어, 개발 문화를 개선하고 코드 품질을 향상시키는 강력한 방법론입니다. 처음에는 '코드를 두 번 작성하는 것 같다'는 생각에 생산성이 떨어진다고 느낄 수 있지만, 장기적으로는 버그를 줄이고, 유지보수 비용을 절감하며, 개발팀 전체의 생산성과 코드에 대한 자신감을 크게 향상시킵니다.

오늘부터 여러분의 프론트엔드 개발에 TDD를 조금씩 적용해보세요. 아마 곧 깨닫게 될 것입니다. TDD가 여러분의 코드를 얼마나 더 단단하고 신뢰할 수 있게 만드는지를요! 다음 포스팅에서는 TDD와 함께 E2E 테스트를 연동하는 방법에 대해 다뤄보겠습니다.

---

## 참고 자료
*   [Implemented a Feature where the Theme on my Portfolio changes based on the Holiday (Because it's fun) 💫](https://dev.to/francistrdev/implemented-a-feature-where-the-theme-on-my-portfolio-changes-based-on-the-holiday-because-its-31jo) by 👾 FrancisTRDev 👾
*   [Test-Driven Development for Building User Interfaces](https://dev.to/thawkin3/test-driven-development-for-building-user-interfaces-4k6d) by Tyler Hawkins
*   [When React Hooks Start Feeling Heavy](https://dev.to/artalar/when-react-hooks-start-feeling-heavy-2njf) by Artyom
*   [Helping your SPA get found](https://dev.to/pantech-kc/helping-your-spa-get-found-i59) by K.C. Sheffield
*   [Why Your React App Feels Slow (Hint: It’s Your Apollo Cache Strategy)](https://dev.to/werliton/why-your-react-app-feels-slow-hint-its-your-apollo-cache-strategy-28b3) by Werliton Silva