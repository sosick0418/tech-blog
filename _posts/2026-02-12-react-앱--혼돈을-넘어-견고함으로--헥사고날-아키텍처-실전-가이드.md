---
layout: post
title: "React 앱, 혼돈을 넘어 견고함으로: 헥사고날 아키텍처 실전 가이드"
date: 2026-02-12T01:01:02.072Z
categories: [frontend, tech]
tags: [react, javascript, nextjs, typescript, tailwindcss]
---

안녕하세요, 프론트엔드 개발 전문 기술 블로거입니다! 2026년 2월 12일, 오늘도 프론트엔드 세계는 빠르게 진화하고 있네요. 오늘은 다양한 기술 트렌드 중에서도 특히 **"React 애플리케이션의 구조와 유지보수성"**이라는 중요한 주제를 다뤄보려고 합니다.

---



안녕하세요, 프론트엔드 개발자 여러분! 복잡해지는 React 애플리케이션의 코드 베이스 앞에서 한숨 쉬어본 경험, 다들 있으실 겁니다. 기능 추가는 어려워지고, 버그는 잡기 힘들어지며, 테스트는 엄두도 내지 못하는 상황... 이러한 혼돈 속에서 벗어나고자 한다면, '헥사고날 아키텍처(Hexagonal Architecture)'가 강력한 해답이 될 수 있습니다. 오늘은 React 프로젝트에 헥사고날 아키텍처를 적용하여 더 견고하고 유지보수하기 쉬운 애플리케이션을 구축하는 방법을 알아보겠습니다.

## 왜 프론트엔드에 아키텍처가 중요할까요?

프론트엔드 개발이 점점 더 복잡해지고, 단일 페이지 애플리케이션(SPA)의 규모가 커지면서 '어떻게 하면 코드를 깔끔하고 확장 가능하게 유지할 수 있을까?'는 중요한 질문이 되었습니다. 특히 React와 같은 컴포넌트 기반 프레임워크에서는 UI 로직과 비즈니스 로직, 데이터 접근 로직이 뒤섞여 스파게티 코드가 되기 쉽습니다. 헥사고날 아키텍처는 이러한 문제를 해결하고, 애플리케이션의 핵심 로직을 외부 환경으로부터 효과적으로 분리하여 유연성과 테스트 용이성을 극대화하는 강력한 방법론입니다.

## 헥사고날 아키텍처의 핵심 개념 이해하기

헥사고날 아키텍처는 'Ports and Adapters' 아키텍처라고도 불리며, 애플리케이션의 핵심 비즈니스 로직(Domain)을 외부 인프라(UI, 데이터베이스, 외부 API 등)로부터 독립시키는 것을 목표로 합니다. 마치 벌집의 육각형처럼, 중심의 비즈니스 로직은 여러 '포트(Port)'를 통해 외부와 소통하고, 이 포트들은 다양한 '어댑터(Adapter)'에 의해 구현됩니다.

핵심은 **의존성 역전 원칙(Dependency Inversion Principle)**입니다. 즉, 내부 레이어는 외부 레이어에 의존하지 않고, 외부 레이어가 내부 레이어의 인터페이스(포트)에 의존합니다. React 프로젝트에서는 다음과 같이 구성할 수 있습니다:

*   **Domain (도메인):** 애플리케이션의 핵심 비즈니스 규칙, 엔티티, 밸류 객체 등 순수한 비즈니스 로직을 정의합니다. 어떤 프레임워크나 외부 라이브러리에도 의존하지 않는 순수한 TypeScript/JavaScript 코드입니다.
*   **Application (애플리케이션):** 유스케이스(Use Case)를 정의하고 Domain 계층을 조율하여 특정 기능을 수행합니다. 외부 입력을 받아 Domain 계층에 전달하고 결과를 반환합니다. 이 계층은 '포트'를 통해 외부 인프라와 소통할 준비를 합니다.
*   **Infrastructure (인프라/어댑터):** UI (React 컴포넌트), 데이터베이스, 외부 API 호출, 인증 서비스 등 실제 외부 기술 구현체입니다. Application 계층에서 정의한 '포트' 인터페이스를 구현하여 외부와 소통하는 '어댑터' 역할을 합니다.

이를 통해 UI가 바뀌거나 데이터 저장 방식이 변경되어도 핵심 비즈니스 로직은 영향을 받지 않는 유연하고 테스트하기 쉬운 구조를 만들 수 있습니다.

## React/Next.js/TypeScript 기반 실전 코드 예시

간단한 사용자 목록을 불러오는 기능을 헥사고날 아키텍처로 구현하는 예시를 통해 실제 적용 방법을 살펴보겠습니다. Next.js 프로젝트를 가정하며, TypeScript를 활용하여 타입 안정성을 확보합니다.

```typescript
// src/domain/user.ts
// 도메인: 사용자 엔티티 정의
export interface User {
  id: string;
  name: string;
  email: string;
}
```

```typescript
// src/ports/userRepository.ts
// 포트: 사용자 데이터를 가져오는 계약 (인터페이스)
import { User } from '../domain/user';

export interface UserRepository {
  getUsers(): Promise<User[]>;
  getUserById(id: string): Promise<User | null>;
}
```

```typescript
// src/application/useCases/getUsers.ts
// 애플리케이션: '사용자 목록 가져오기' 유스케이스
import { User } from '../../domain/user';
import { UserRepository } from '../../ports/userRepository';

export class GetUsersUseCase {
  private userRepository: UserRepository;

  // 생성자를 통해 의존성 주입 (Dependency Injection)
  constructor(userRepository: UserRepository) {
    this.userRepository = userRepository;
  }

  async execute(): Promise<User[]> {
    // 순수 비즈니스 로직 (여기서는 단순히 데이터 가져오기)
    // 필요하다면 여기서 추가적인 도메인 로직을 처리할 수 있습니다.
    return this.userRepository.getUsers();
  }
}
```

```typescript
// src/infrastructure/apiUserRepository.ts
// 인프라/어댑터: 실제 외부 API를 호출하여 포트를 구현
import { User } from '../../domain/user';
import { UserRepository } from '../../ports/userRepository';

export class ApiUserRepository implements UserRepository {
  async getUsers(): Promise<User[]> {
    // 실제 API 호출 로직
    const response = await fetch('https://jsonplaceholder.typicode.com/users'); // 예시 API
    if (!response.ok) {
      throw new Error('Failed to fetch users');
    }
    const data: any[] = await response.json();
    return data.map((item) => ({
      id: item.id.toString(),
      name: item.name,
      email: item.email,
    }));
  }

  async getUserById(id: string): Promise<User | null> {
    // ... 특정 사용자 가져오기 구현
    return null;
  }
}
```

```typescript
// src/app/users/page.tsx (Next.js App Router 페이지)
// UI/어댑터: React 컴포넌트에서 유스케이스를 사용
'use client'; // 클라이언트 컴포넌트임을 명시

import React, { useEffect, useState } from 'react';
import { User } from '../../domain/user';
import { GetUsersUseCase } from '../../application/useCases/getUsers';
import { ApiUserRepository } from '../../infrastructure/apiUserRepository';

const userRepository = new ApiUserRepository(); // 실제 구현체 인스턴스 생성
const getUsersUseCase = new GetUsersUseCase(userRepository); // 유스케이스에 의존성 주입

const UserListPage: React.FC = () => {
  const [users, setUsers] = useState<User[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchUsers = async () => {
      try {
        const fetchedUsers = await getUsersUseCase.execute(); // 유스케이스 실행
        setUsers(fetchedUsers);
      } catch (err) {
        setError('사용자 정보를 불러오는 데 실패했습니다.');
        console.error(err);
      } finally {
        setLoading(false);
      }
    };
    fetchUsers();
  }, []);

  if (loading) return <div>사용자 목록 로딩 중...</div>;
  if (error) return <div>에러: {error}</div>;

  return (
    <div style={{ padding: '20px' }}>
      <h1>사용자 목록</h1>
      <ul>
        {users.map((user) => (
          <li key={user.id} style={{ marginBottom: '10px' }}>
            <strong>{user.name}</strong> ({user.email})
          </li>
        ))}
      </ul>
    </div>
  );
};

export default UserListPage;
```

위 예시에서 `UserListPage` 컴포넌트는 `GetUsersUseCase`라는 애플리케이션 계층의 유스케이스와 소통합니다. `GetUsersUseCase`는 `UserRepository`라는 포트에 의존하며, 실제 데이터는 `ApiUserRepository`라는 어댑터가 구현합니다. 이렇게 계층을 분리함으로써, 만약 나중에 데이터를 로컬 스토리지에서 가져오거나 GraphQL API로 변경하더라도 `UserListPage`와 `GetUsersUseCase`는 거의 수정할 필요 없이 `ApiUserRepository`만 새로운 어댑터로 교체하면 됩니다.

## 실무 적용 팁과 고려사항

헥사고날 아키텍처는 분명 많은 이점을 제공하지만, 모든 프로젝트에 만능 해결책은 아닙니다.

*   **점진적으로 적용하세요:** 처음부터 모든 것을 헥사고날로 만들려 하지 말고, 핵심 도메인부터 적용하며 점진적으로 확장하는 것이 좋습니다. 특히 신규 기능 개발 시 이 패턴을 적용해보는 것부터 시작할 수 있습니다.
*   **테스트 용이성:** 각 계층이 명확히 분리되므로, 유스케이스와 도메인 로직을 외부 인프라 없이 순수하게 테스트할 수 있습니다. Mocking이 훨씬 쉬워져 견고한 테스트 스위트를 구축하는 데 유리합니다.
*   **팀 협업:** 각 계층의 역할이 명확하여 여러 개발자가 동시에 다른 부분을 작업해도 충돌이 적고, 코드 리뷰가 용이해집니다. 새로운 팀원이 합류했을 때도 구조를 이해하기 쉽습니다.
*   **과도한 추상화 경계:** 작은 프로젝트에서는 오히려 복잡성을 증가시킬 수 있습니다. 파일 구조가 많아지고 초기 설정 비용이 발생할 수 있으므로, 팀의 규모, 프로젝트의 수명, 예상되는 복잡성을 고려하여 신중하게 결정해야 합니다. 대규모의 장기적인 프로젝트나 비즈니스 로직이 복잡한 애플리케이션에 특히 유용합니다.
*   **의존성 주입(DI) 컨테이너 활용:** 예시에서는 간단하게 `new` 키워드를 사용했지만, 실제 대규모 프로젝트에서는 InversifyJS, TypeDI와 같은 DI 컨테이너를 활용하여 의존성 관리를 더욱 체계적이고 자동화할 수 있습니다.

## 마무리하며: 프론트엔드의 미래를 위한 선택

오늘 우리는 React 프로젝트에 헥사고날 아키텍처를 적용하는 기본적인 개념과 실용적인 접근법을 살펴보았습니다. 이 아키텍처는 React 애플리케이션이 성장함에 따라 발생하는 유지보수성, 테스트 용이성, 유연성 문제를 해결하는 데 큰 도움을 줄 것입니다. 비즈니스 로직을 UI나 데이터 저장 방식으로부터 분리함으로써, 변화에 강하고 확장 가능한 프론트엔드 애플리케이션을 구축할 수 있습니다.

물론, 아키텍처는 정답이 없으며 프로젝트의 특성에 따라 최적의 선택은 달라질 수 있습니다. 하지만 헥사고날 아키텍처와 같은 패턴을 이해하고 적용하려는 노력은 여러분의 프론트엔드 개발 역량을 한 단계 더 성장시키는 중요한 밑거름이 될 것입니다. 다음 단계로는 DI(Dependency Injection) 컨테이너를 활용하여 의존성 관리를 더욱 효율적으로 하는 방법, 혹은 Clean Architecture와 같은 다른 아키텍처 패턴과의 비교를 통해 자신에게 맞는 최적의 구조를 탐색해보는 것을 추천합니다.

---

## 참고 자료

*   [FormEngine vs RJSF: An Honest Bundle Size Comparison of Two JSON Schema Form Libraries](https://dev.to/optimajet/formengine-vs-rjsf-an-honest-bundle-size-comparison-of-two-json-schema-form-libraries-133n) by Optimajet Limited
*   [I Built a Free Synthetic Data Generator — Here's How (React + Tailwind)](https://dev.to/rahultyagi1994/i-built-a-free-synthetic-data-generator-heres-how-react-tailwind-10a8) by Rahultyagi1994
*   [Implementando Arquitectura Hexagonal en React: Una Guía Práctica Completa](https://dev.to/carlosgmdev/implementando-arquitectura-hexagonal-en-react-una-guía-práctica-completa-4mk) by Carlos Martínez
*   [Build an Advance Weather APP With ReactJS](https://dev.to/codewithsadee/build-an-advance-weather-app-with-reactjs-2joa) by Sadee
*   [sunpeak is all-in on MCP Apps](https://dev.to/abewheeler/sunpeak-is-all-in-on-mcp-apps-2lg8) by Abe Wheeler